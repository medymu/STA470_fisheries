---
title: "LMM_fisheries"
author: "Medy Mu"
date: '2022-10-13'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(dplyr)
library(ggplot2)
library(lme4)
library(broom.mixed)
library(knitr)
library(patchwork)
library(nlme)
```

## 1. Input Data; Basic Data Processing
```{r}
x<-read.csv("fullSetWithMask.csv",as.is=TRUE,
            na.strings=c("NA",".",""," "))
dim(x) ## Check the dimension (number of rows and columns) of the data matrix.
head(x)
```


```{r}
## Drop Column of Row Numbers:
x<-x[,-1]
## Rename a Few Variables:
colnames(x)[colnames(x)=="taxa_grouped_weight"]<-"taxa"
colnames(x)[colnames(x)=="agremiacion_fed"]<-"fed"
colnames(x)[colnames(x)=="coop_edad_10"]<-"age"
colnames(x)[colnames(x)=="rr"]<-"region"
x$uniqueid<-as.factor(x$uniqueid)
x$fed<-as.factor(x$fed)
x$taxa<-as.factor(x$taxa)
x$region<-as.factor(x$region)
x$yearFactor<-as.factor(x$year)
x$monthFactor<-as.factor(x$month)
```

## 2. Basic Summaries
```{r}
table(x$taxa,useNA="always")
table(x$region,useNA="always")
length(unique(x$uniqueid))
length(unique(x$fed))
table(x$year)
summary(x$age)
summary(x$age[x$uniqueid=="00000-BCSCAM"])
x$age2<-((10*x$age) + (x$year - 2016))
summary(x$age2)
table(x$age2<0)
tbl<-table(as.character(x$uniqueid)[x$age2<0]); tbl
table(x$age2[x$uniqueid %in% names(tbl)],
      as.character(x$uniqueid[x$uniqueid %in% names(tbl)]),
      useNA="always")
## Naive Age Fix (the years associated w/ these samples may be incorrect):
x$age[(x$uniqueid=="00549-TAB")&(x$age2<0)]<-(x$age[(x$uniqueid=="00549-TAB")&(x$age2<0)] + 0.5)
x$age[(x$uniqueid=="00685-BCS")&(x$age2<0)]<-(x$age[(x$uniqueid=="00685-BCS")&(x$age2<0)] + 0.2)
x$age[(x$uniqueid=="00747-YUC")&(x$age2<0)]<-(x$age[(x$uniqueid=="00747-YUC")&(x$age2<0)] + 0.6)
x$age[(x$uniqueid=="00748-YUC")&(x$age2<0)]<-(x$age[(x$uniqueid=="00748-YUC")&(x$age2<0)] + 0.2)
x$age2<-((10*x$age) + (x$year - 2016))
summary(x$age2)
```

## 2.2 Taxa by coop

```{r}
tbl<-table(x$uniqueid,x$taxa)
dim(tbl)
summary(coopByTaxa<-as.numeric(tbl))
table(coopByTaxa==0)
coopByTaxa<-coopByTaxa[coopByTaxa>0]
hist(coopByTaxa,nclass=50,las=1)
```

## 3. Client's LME model


Note, from the nlme::ACF documentation: “This method function calculates the empirical autocorrelation function for the within-group residuals from an lme fit. The autocorrelation values are calculated using pairs of residuals within the innermost group level. The autocorrelation function is useful for investigating serial correlation models for equally spaced data.”

### 3.1 Full data set

```{r}
keep<-(!is.na(x$logcpue))
lme.out<-nlme::lme(logcpue ~ age + yearFactor + monthFactor + region + taxa,
                   random = ~ 1|fed/uniqueid, data=x,subset=keep)
summary(lme.out)$tTable
acf.lme<-nlme::ACF(lme.out,maxLag=15)
plot(acf.lme,alpha=0.01/15)
```

```{r}
acf.lme<-acf.lme[-1,]
plot(acf.lme,alpha=0.005)
```

```{r}
qqnorm(fedn.re<-unlist(nlme::ranef(lme.out)$fed),las=1)
abline(a=0,b=sd(fedn.re),lwd=2,col=2)
```

```{r}
qqnorm(uid.re<-unlist(nlme::ranef(lme.out)$uniqueid))
abline(a=0,b=sd(uid.re),lwd=2,col=2)
```

### 3.2 Single taxa model

```{r}
keep<-((x$taxa=="OTRAS")&(!is.na(x$logcpue)))
otras.out<-nlme::lme(logcpue ~ age + yearFactor + monthFactor + region,
                     random = ~ 1|fed/uniqueid, data=x,subset=keep)
summary(otras.out)$tTable

acf.otras<-nlme::ACF(otras.out,maxLag=15)
plot(acf.otras,alpha=0.01/15)
```

```{r}
acf.otras<-acf.otras[-1,]
plot(acf.otras,alpha=0.005)
```

```{r}
qqnorm(fedn.re<-unlist(nlme::ranef(otras.out)$fed),las=1)
abline(a=0,b=sd(fedn.re),lwd=2,col=2)
```

```{r}
qqnorm(uid.re<-unlist(nlme::ranef(otras.out)$uniqueid))
abline(a=0,b=sd(uid.re),lwd=2,col=2)
```

## 4 Your mgcv Models

```{r}
response_summary <- x %>%
    summarise(mean = mean(logcpue, na.rm=TRUE),
            median = median(logcpue, na.rm=TRUE),
            variance = var(logcpue, na.rm=TRUE),
            IQR = IQR(logcpue, na.rm=TRUE),
            sd = sd(logcpue, na.rm=TRUE),
            min = min(logcpue, na.rm=TRUE),
            max = max(logcpue, na.rm=TRUE))
knitr::kable(response_summary, caption = "Summary Statistics for \n the logcpue")
```

```{r}
ggplot(data = x, aes(x = logcpue)) +
  geom_histogram(fill = "darkgreen", color = "black") +
  labs(x = "logcpue", y = "Count",
       title = "Distribution of logcpue",
       caption = "Figure 1") +
  theme_bw() +
  theme(axis.title = element_text(size = 9),
        plot.title = element_text(size = 10),
        plot.caption = element_text(size = 9)) +
  theme(text = element_text(family = "serif")) +
  theme(plot.title=element_text(family = "serif", face = "bold", hjust = 0.5)) 
```

In this dataset, the response variable is `logcpue`, which represents catch per unit of effort, measured during different time points (Figure 1, Table 1). The distribution of this variable is unimodal and slightly skewed to the left. The center, defined by median, is 1.97. The spread, defined by the interquartile range (IQR), is 2.89. There are no evident outliers based on the histogram shown in Figure 1. To better capture the distribution of logcpue for individual organizations, a random sample of 30 organizations were selected, and their logcpue measured at different time points were plotted (Figure 2). Indeed, organizations exhibit different patterns for the distribution of logcpue. Some shows a bimodel distribution, while some shows a unimodel distribution, This suggests that the distribution of logcpue differs based on organizations, so we decided to include it as an individual level in our LMM model.

```{r, fig.width = 10, fig.height = 6}
set.seed(031622)
# get sample of 30 cooperations
  
sample_org <- x %>%
  distinct(uniqueid) %>%
  sample_n(30) %>% pull()
# get data for those organizations
sample_data <- x %>%
  filter(uniqueid %in% sample_org)
# make a histogram of the response for each lemur
ggplot(data = sample_data, aes(x = logcpue)) +
  geom_histogram(fill = "darkgreen", color = "black") +
  facet_wrap(~ uniqueid, scales = "free") +
  labs(x = "logcpue",
       title = "Distribution of logcpue by randomly sampled 30 organizations",
       caption = "Figure 2") +
  theme(strip.text.x = element_text(size = 6),
        axis.text.x = element_text(size= 5),
        axis.text.y = element_text(size= 5),
        plot.caption = element_text(size = 13),
        axis.title = element_text(size = 13),
        plot.title = element_text(size = 14)) +  
  theme_bw() +
  theme(text = element_text(family = "serif")) +
  theme(plot.title=element_text(family = "serif", face = "bold", hjust = 0.5)) 
```

Other variables in the data that are of interests include year and month of each fishing event, region, taxa, and age of the federations. Figure 3 shows the relationships between year and logcpue for 30 randomly selected organizations. Figure 4 shows the relationships between month and logcpue for 30 randomly selected organizations. While some organizations have a constant logcpue value across years or months, some organizations have varying logcpue based on the year or month the fishery takes place, indicating that time alone cannot explain the distribution of logcpue observed and other factors during the year or month logcpue was collected may play a role in determining the pattern of logcpue. 

```{r, fig.width = 9, fig.height = 7}
ggplot(data = sample_data, aes(x = yearFactor, y = logcpue)) +
  geom_boxplot(fill = "darkgreen", color = "black") +
  facet_wrap(~ uniqueid, scales = "free") +
  labs(x = "Year",
       y = "logcpue",
       title = "logcpue vs year",
       caption = "Figure 3") +
  theme(strip.text.x = element_text(size = 6),
        axis.text.x = element_text(size= 5),
        axis.text.y = element_text(size= 5),
        plot.caption = element_text(size = 13),
        axis.title = element_text(size = 13),
        plot.title = element_text(size = 14)) +  
  theme_bw() +
  theme(text = element_text(family = "serif")) +
  theme(plot.title=element_text(family = "serif", face = "bold", hjust = 0.5)) 
```

```{r, fig.width = 9, fig.height = 7}
ggplot(data = sample_data, aes(x = monthFactor, y = logcpue)) +
  geom_boxplot(fill = "darkgreen", color = "black") +
  facet_wrap(~ uniqueid, scales = "free") +
  labs(x = "Month",
       y = "logcpue",
       title = "logcpue vs month",
       caption = "Figure 4") +
  theme(strip.text.x = element_text(size = 6),
        axis.text.x = element_text(size= 5),
        axis.text.y = element_text(size= 5),
        plot.caption = element_text(size = 13),
        axis.title = element_text(size = 13),
        plot.title = element_text(size = 14)) +  
  theme_bw() +
  theme(text = element_text(family = "serif")) +
  theme(plot.title=element_text(family = "serif", face = "bold", hjust = 0.5)) 
```

Therefore, a new continuous variable that incorporated both year and month is created. 

```{r}
x$yearMonth <- ((x$year - min(x$year)) *12 + x$month)
```

In addition to year and month, region and taxa also play an important role in explaining logcpue. In particular, logcpue differs based on the region where the fisheries take place and on the taxa of the fish caught (Figure 5,6). Therefore, these two variables are worth including in the final models.

```{r}
x_na <- na.omit(x)
```

```{r}
region <- ggplot(data = x_na, aes(x = region, y = logcpue)) +
  geom_boxplot(fill = "darkgreen", color = "black") +
  labs(x = "Region", 
       y = "logcpue",
       title = "logcpue vs. region",
       caption = "Figure 5") +
  theme_bw() 
```

```{r}
taxa<- ggplot(data = x_na, aes(x = taxa, y = logcpue)) +
  geom_boxplot(fill = "darkgreen", color = "black") +
  labs(x = "Taxa",
       y = "logcpue",
       title = "logcpue vs. taxa",
       caption = "Figure 6") +
  theme_bw() 
```

```{r}
region + taxa
```

## Methods

Since catch per unit of efforts (cpue) were measured at different time points for each organization and that organizations from the same federations tend to have similar distribution of logcpue, a multilevel model analysis was used to model the distribution of logcpue. The multilevel analysis was done at three levels. The first level included time points when cpue were collected; the second level included individual organizations (``uniqueid``); and the third level included federations (``fed``). To test whether a multilevel model is necessary to capture the distribution of logcpue, an unconditional means model in which there are no predictors at any level was first fitted, and intraclass correlation was calculated to estimate the relative variability between organizations and between federations (Table 2). Indeed, the intraclass correlation for organizations is about `r round(1.093864^2/ (1.093864^2 + 1.189196^2 + 1.687456^2), 2)` and for federations is about `r round(1.189196^2/ (1.093864^2 + 1.189196^2 + 1.687456^2), 2)`, which means that the average correlation between any two responses from the same organization or from the same federations is about `r round(1.093864^2/ (1.093864^2 + 1.189196^2 + 1.687456^2), 2)` and `r round(1.189196^2/ (1.093864^2 + 1.189196^2 + 1.687456^2), 2)` respectively. This suggests that about 48% of the variability in the logcpue is explained by organization to organization variability and federation to federation variability. Knowing organization and federation, therefore, can explain almost half of the variability in the data, providing evidence that the multilevel model structure is useful in this setting.

```{r, cache=TRUE}
unconditional_means <- lme(logcpue ~ 1, 
                          list(fed = ~1, uniqueid = ~1), 
                           data = x, na.action = na.omit)
summary(unconditional_means)
```

Next, to understand the effect of time before adding other Level One covariates, the model that only includes year and month as Level One predictors was fitted (Table 3). The Pseudo $R^2$ estimating the change in within-organization variance between the unconditional means and the Model with Time is about 0.42. Therefore, understanding changes of time (i.e. years) accounts for 42% variability in logcpue.

```{r, cache=TRUE}
model_time <- lme(logcpue ~ yearMonth, list(fed = ~yearMonth, uniqueid = ~yearMonth), data = x, na.action = na.omit)
summary(model_time)
```

```{r}
# Pseudo R^2
sigm_moda <- 1.687456^2
sigm_madb <- 1.64283974 
r <- (sigm_moda - sigm_madb)/sigm_moda
r
```

Based on the EDA and model with only time as level one predictors, we decided to include `yearMonth`, `region`, and `taxa` as our level one predictors. `age2` was included as level three (federation) predictor since we hypothesized that the age of federation would impact the efficiency of catching fish (logcpue) of its subsidiary cooperation. Therefore, two models were fitted. One that includes interactions between age of federations and region and between age of federations and taxa, and one that does not include any interactions. AIC and BIC of both models were compared. Since both AIC and BIT are lower for model with additional interaction effects, providing evidence that model with interactions is a better model, which is our final model. One thing to note is that no random slopes were included in level two or three in both model because adding them make the model too complex and too computational heavy.

```{r, cache=TRUE}
model_no_int <- lme(logcpue ~ yearMonth + region + taxa + age2, 
                     list(fed = ~1, uniqueid = ~1), 
                            data = x, na.action = na.omit)
summary(model_no_int)
```

```{r, cache=TRUE}
model_int <- lme(logcpue ~ yearMonth + region + taxa + age2 + age2:region + age2:taxa, 
                     list(fed = ~1, uniqueid = ~1), 
                            data = x, na.action = na.omit)
summary(model_int)
```

**Level 1 Model: Time**

$$ Logcpue_{ijk} = a_{ij} + b_{ij} yearMonth_{ijk} + c_{ij} region_{ijk} + d_{ij} taxa_{ijk} + \epsilon_{ijk}, \space \epsilon_{ijk} \sim N(0, \sigma^2)$$

**Level 2 Model: Organizations**

$$a_{ij} = a_i + u_{ij}$$

$$b_{ij} = b_i $$

$$c_{ij} = c_i$$

$$d_{ij} = d_i$$

**Level 3 Model: Federations**

$$a_{i} = \alpha_0 + \alpha_1 age_{i} + \tilde u_{i}$$

$$b_{i} = \beta_0 $$

$$c_{i} = \gamma_0  + \gamma_1 age_{i}$$

$$d_{i} = \delta_0 + \delta_1 age_{i} $$


**Composite model**

$$ Logcpue_{ijk} = a_i + u_{ij} + b_i yearMonth_{ijk} + c_i region_{ijk} + d_i taxa_{ijk} + \epsilon_{ijk}, \space \epsilon_{ijk} \sim N(0, \sigma^2)$$


$$ = \alpha_0 + \alpha_1 age_{i} + \tilde u_{i} + u_{ij} + \beta_0 yearMonth_{ijk} + \gamma_0 region_{ijk} + \gamma_1 age_{i} region_{ijk} + \delta_0 taxa_{ijk}+ \delta_1 age_{i} taxa_{ijk} + \epsilon_{ijk}$$
$$\space \epsilon_{ijk} \sim N(0, \sigma^2)$$
$$ = \alpha_0 + \alpha_1 age_{i} + \beta_0 yearMonth_{ijk} + \gamma_0 region_{ijk} + \gamma_1 age_{i} region_{ijk} + \delta_0 taxa_{ijk} + \delta_1 age_{i} taxa_{ijk}$$
$$+ [\tilde u_{i} + u_{ij} + \epsilon_{ijk}] $$
$$\epsilon_{ijk} \sim N(0, \sigma^2),u_{ij} \sim N(0, \sigma_{u}^2), \tilde u_{i} \sim N(0, \sigma_{\tilde u}^2)$$

## Model Diagnostics

### linearity 

```{r}
ggplot(data.frame(yearMonth=x_na$yearMonth,pearson=residuals(model_int,type="pearson")),
      aes(x=yearMonth,y=pearson)) +
    geom_point() +
    theme_bw()
```

The residuals are randomly scattered, suggesting that there is linear relationship for yearMonth.

## Normality

```{r}
qqnorm(residuals(model_int))
```

## Residual plot

```{r}
plot(model_int)
```


